<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>StreamDevice: Bus API</title>
<link rel="shortcut icon" href="sls_icon.ico">
<link rel="stylesheet" type="text/css" href="stream.css">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="author" content="Dirk Zimoch">
<style>
.indent {text-indent:-4ex; margin-left:4ex; margin-top:0.5ex;text-align:left;}
</style>
</head>
<body>
<h1>Bus API</h1>

<h2>Bus Interface Class</h2>
<p>
<em>StreamDevice</em> already comes with an interface to <a target="ex"
    href="http://www.aps.anl.gov/epics/modules/soft/asyn/">
    <em>asynDriver</em></a>.
You should first try to implement your bus driver compatible to
<em>asynDriver</em>.
Then it can be used by <em>StreamDevice</em> automatically.
Only if that does not work, write your own bus interface.
</p>
<p>
A bus interface is a C++ class that inherits from
<em>StreamBusInterface</em>.
Its purpose is to provide an interface to <em>StreamDevice</em> for a
low-level I/O bus driver.
<em>StreamDevice</em> acts as a client of the interface, calling interface
methods and receiving replies via callbacks.
Since the internal details of <em>StreamDevice</em> are not of
interest to a bus interface, I will reference it simply as
<em>client</em> in this chapter.
The interface class must be registered via a call to
<code><a href="#registration">
RegisterStreamBusInterface</a>()</code>
in the global context of the C++ file (not in a header file).
</p>
<p>
Interface methods called by the client must not block for arbitrary
long times.
That means the interface is allowed to take mutex semaphores to protect
its internal data structures but it must not take event semaphores to 
wait for external I/O or similar.
</p>
<p>
It is assumed that the interface creates a separate thread to handle
blocking I/O and to call the callback methods in the context of that
thread when I/O has completed.
The callback methods don't block but may in turn call interface methods.
Much of the actual work will be done in the context of those callbacks,
i.e. in the interface thread, thus be generous with stack.
</p>

<h3>Example bus interface class declaration</h3>
<pre>
#include &lt;StreamBusInterface.h&gt;

class MyInterface : StreamBusInterface
{
    // ... (internally used attributes and methods)

    MyInterface(Client* client);
    ~MyInterface();

    // StreamBusInterface virtual methods
    bool lockRequest(unsigned long lockTimeout_ms);
    bool unlock();
    bool writeRequest(const void* output, size_t size,
        unsigned long writeTimeout_ms);
    bool readRequest(unsigned long replyTimeout_ms,
        unsigned long readTimeout_ms,
        long expectedLength, bool async);
    bool acceptEvent(unsigned long mask,
        unsigned long replytimeout_ms);
    const char* busName();
    void release();
    bool supportsEvent();
    bool supportsAsyncRead();

public:
    // creator method
    static StreamBusInterface* getBusInterface(
        Client* client, const char* busname,
        int addr, const char* param);
};

// ... (implementation)

RegisterStreamBusInterface(MyInterface);
</pre>

<h3>Methods to implement</h3>
<p>
The interface class must implement a public static creator method:
</p>
<div class="indent"><code>
static StreamBusInterface*
    <a href="#create">getBusInterface</a>(Client*&nbsp;client,
        const&nbsp;char*&nbsp;busname, int&nbsp;addr,
        const&nbsp;char*&nbsp;param);
</code></div>
<p>
And it must implement the following pure virtual methods:
</p>
<div class="indent"><code>
bool <a href="#lock">lockRequest</a>(unsigned&nbsp;long&nbsp;lockTimeout_ms);
</code></div>
<div class="indent"><code>
bool <a href="#lock">unlock</a>();
</code></div>
<div class="indent"><code>
bool <a href="#write">writeRequest</a>(const&nbsp;void*&nbsp;output,
    size_t&nbsp;size, unsigned&nbsp;long&nbsp;writeTimeout_ms);
</code></div>
<div class="indent"><code>
bool <a href="#read">readRequest</a>(unsigned&nbsp;long&nbsp;replyTimeout_ms,
    unsigned&nbsp;long&nbsp;readTimeout_ms,
    long&nbsp;expectedLength, bool&nbsp;async);
</code></div>
<p>
It may implement additional virtual methods if the bus supports
events and/or asynchronous reads:
<div class="indent"><code>
bool <a href="#read">supportsAsyncRead</a>();
</code></div>
<div class="indent"><code>
bool <a href="#event">supportsEvent</a>();
</code></div>
<div class="indent"><code>
bool <a href="#event">acceptEvent</a>(unsigned&nbsp;long&nbsp;mask, 
    unsigned&nbsp;long&nbsp;replytimeout_ms);
</code></div>
</p>
<p>
It also may override the following virtual methods:
<div class="indent"><code>
bool <a href="#read">setEos</a>(const&nbsp;char*&nbsp;eos,
    size_t&nbsp;eoslen);
</code></div>
<div class="indent"><code>
void <a href="#create">release</a>();
</code></div>
</p>

<h3>Callback methods provided</h3>
<p>
The base class <em>StreamBusInterface</em> implements a set of protected
callback methods which should be called in response to the above request
methods:
</p>
<div class="indent"><code>
void <a href="#lock">lockCallback</a>(IoStatus&nbsp;status);
</code></div>
<div class="indent"><code>
void <a href="#write">writeCallback</a>(IoStatus&nbsp;status);
</code></div>
<div class="indent"><code>
long <a href="#read">readCallback</a>(IoStatus&nbsp;status,
        const&nbsp;void*&nbsp;input&nbsp;=&nbsp;NULL,
        long&nbsp;size&nbsp;=&nbsp;0);
</code></div>
<div class="indent"><code>
void <a href="#event">eventCallback</a>(IoStatus&nbsp;status);
</code></div>

<h3>Other provided methods, attibutes, and types</h3>

<div class="indent"><code>
<a href="#create">StreamBusInterface</a>(Client*&nbsp;client);
</code></div>
<div class="indent"><code>
long <a href="#lock">priority</a>();
</code></div>
<div class="indent"><code>
const char* <a href="#create">clientName</a>();
</code></div>
<div class="indent"><code>
const&nbsp;char*&nbsp;eos;
</code></div>
<div class="indent"><code>
size_t&nbsp;eoslen;
</code></div>
<div class="indent"><code>
enum&nbsp;IoStatus {ioSuccess, ioTimeout, ioNoReply, ioEnd, ioFault};
</code></div>

<h2>Theory of operation</h2>

<a name="registration"></a>
<h3>Registration</h3>
<div class="indent"><code>
RegisterStreamBusInterface(<i>interfaceClass</i>);
</code></div>
<p>
During initialization, the macro <code>RegisterStreamBusInterface()</code>
registers the bus interface.
It must be called exactly once for each bus interface class in global
file context.
</p>

<a name="create"></a>
<h3>Creation and deletion</h3>
<div class="indent"><code>
static StreamBusInterface* getBusInterface(Client*&nbsp;client,
    const&nbsp;char*&nbsp;busname, int&nbsp;addr,
    const&nbsp;char*&nbsp;param);
</code></div>
<div class="indent"><code>
StreamBusInterface(Client*&nbsp;client);
</code></div>
<div class="indent"><code>
void release();
</code></div>
<div class="indent"><code>
const char* clientName();
</code></div>

<p>
During startup, each client instance searches for its bus interface
by name.
It does so by calling the static <code>getBusInterface()</code> method
of every registered interface class.
This method should check by <code>busname</code> if its interface class
is responsible for that bus.
If yes, it should check if the address <code>addr</code> is valid and
associate a <em>device</em> with <code>busname</code>/<code>addr</code>.
Some busses do not have addresses and allow only one device
(e.g. RS232).
Interfaces to such busses can ignore <code>addr</code>.
The bus interface may then try to connect to the device, but it should
allow it to be disconnected or switched off at the moment.
If the bus interface requires additional parameters, parse the
<code>param</code> string.
Your constructor should pass <code>client</code> to the base class
constructor <code>StreamBusInterface(Client* client)</code>.
</p>
<p>
On success, <code>getBusInterface</code> should then return a pointer
to a bus interface instance.
Note that many client instances may want to connect to the same device.
Each needs its own bus interface instance.
The bus interface can get a string containing the name of the 
client instance from <code>clientName()</code>.
This name is for use in error and log messages.
</p>
<p>
On failure, or if this interface class is not responsible for that bus,
getBusInterface should return <code>NULL</code>.
The client will then try other bus interface classes.
</p>
<p>
When the client does not need the interface any more, it calls
<code>release()</code>.
The default implementation of <code>release()</code> assumes that
<code>getBusInterface()</code> has allocated a new bus interface
and just calls <code>delete</code>.
You should change <code>release()</code> if that assumption is not
correct.
</p>

<a name="lock"></a>
<h3>Bus locking</h3>
<div class="indent">
<code>bool lockRequest(unsigned&nbsp;long&nbsp;lockTimeout_ms);</code>
</div>
<div class="indent">
<code>void lockCallback(IoStatus&nbsp;status);</code>
</div>
<div class="indent">
<code>bool unlock();</code>
</div>
<div class="indent">
<code>long priority();</code>
</div>
<p>
Before doing output, the client calls <code>lockRequest()</code> to get
exclusive access to the device.
This function should return immediately.
If the device is already locked, the bus interface should add itself to
a queue, sorted by <code>priority()</code>.
As soon as the device is available, the bus interface should call
<code>lockCallback(ioSuccess)</code>.
If the bus cannot be locked within <code>lockTimeout_ms</code>
milliseconds, the bus interface should call
<code>lockCallback(ioTimeout)</code>.
</p>
<p>
If a device cannot be locked, for example because it is known to be
offline, <code>lockCallback(ioFault)</code> may be called.
</p>
<p>
Normally, it is not necessary to lock the complete bus but only one
devices (i.e. one address).
Other clients should still be able to talk to other devices on the same bus.
</p>
<p>
The client may perform several read and write operations when it has
locked the device.
When the dialog with the device has ended, the client calls
<code>unlock()</code>.
If other bus interfaces are in the lock queue, the next one should
call <code>lockCallback(ioSuccess)</code> now.
</p>

<a name="write"></a>
<h3>Writing output</h3>
<div class="indent">
<code>
bool writeRequest(const&nbsp;void*&nbsp;output,
    size_t&nbsp;size, unsigned&nbsp;long&nbsp;writeTimeout_ms);
</code>
</div>
<div class="indent">
<code>
void writeCallback(IoStatus&nbsp;status);
</code>
</div>
<p>
To start output, the client calls <code>writeRequest()</code>.
You can safely assume that the device has already been locked at this
time.
That means, no other client will call <code>writeRequest()</code>
for this device and no other output is currently active for this device
until it has been unlocked.
</p>
<p>
The function should arrange transmission of <code>size</code> bytes of
<code>output</code> but return immediately without blocking.
After all output has been successfully transmitted, but not earlier, the
interface should call <code>writeCallback(ioSuccess)</code>.
</p>
<p>
If output blocks for <code>writeTimeout_ms</code> milliseconds,
the interface should abort the transmision and call
<code>writeCallback(ioTimeout)</code>.
</p>
<p>
If output is impossible, e.g. because the device is known to be offline,
the interface may call <code>writeCallback(ioFault)</code>.
</p>
<p>
The interface must transmit excactly the <code>size</code> bytes
from <code>output</code>.
It must not append or change anything and it should not assume that
any bytes have a special meaning.
In particular, a null byte does not terminate <code>output</code> and
no terminator must be added.
The buffer referenced by <code>output</code> stays valid until
<code>writeCallback()</code> is called.
</p>
The client may request more I/O or call <code>unlock()</code> after
<code>writeCallback()</code> has been called.
</p>

<a name="read"></a>
<h3>Reading input</h3>
<div class="indent"><code>
bool readRequest(unsigned&nbsp;long&nbsp;replyTimeout_ms,
    unsigned&nbsp;long&nbsp;readTimeout_ms,
    long&nbsp;expectedLength, bool&nbsp;async);
</code></div>
<div class="indent"><code>
long readCallback(IoStatus&nbsp;status,
        const&nbsp;void*&nbsp;input&nbsp;=&nbsp;NULL,
        long&nbsp;size&nbsp;=&nbsp;0);
</code></div>
<div class="indent"><code>
bool setEos(const&nbsp;char*&nbsp;eos,
    size_t&nbsp;eoslen);
</code></div>
<div class="indent"><code>
bool supportsAsyncRead();
</code></div>
<p>
To prepare for input, the client calls <code>readRequest()</code>.
This can also happen on an unlocked device.

<hr>
<p><small>Dirk Zimoch, 2006</small></p>
<script src="stream.js" type="text/javascript"></script>
</body>
</html>
